---
description:
globs:
alwaysApply: false
---
# AI é›†æˆè§„èŒƒ

@context {
  "type": "ai_integration",
  "sdk": "Vercel AI SDK 3.4+",
  "provider": "OpenAI",
  "models": ["gpt-4o", "gpt-4o-mini"],
  "features": ["streaming", "tool_calling", "structured_output"]
}

## AI SDK é…ç½®è§„åˆ™

@ai_config_rules [
  {
    "id": "centralized_config",
    "rule": "AI é…ç½®é›†ä¸­åœ¨ ai/ ç›®å½•",
    "severity": "warning"
  },
  {
    "id": "model_abstraction",
    "rule": "ä½¿ç”¨æ¨¡å‹æŠ½è±¡å±‚",
    "severity": "warning"
  },
  {
    "id": "streaming_first",
    "rule": "ä¼˜å…ˆä½¿ç”¨æµå¼å“åº”",
    "severity": "warning"
  },
  {
    "id": "error_handling",
    "rule": "å¤„ç† AI æœåŠ¡é”™è¯¯",
    "severity": "error"
  }
]

```typescript
// âœ… AI SDK é…ç½® (ai/index.ts)
import { openai } from '@ai-sdk/openai';
import { createAI } from 'ai/rsc';
import { DEFAULT_MODEL_NAME } from './models';

export const ai = createAI({
  model: openai(DEFAULT_MODEL_NAME),
  initial: [],
});

// âœ… æ¨¡å‹é…ç½® (ai/models.ts)
export interface Model {
  id: string;
  label: string;
  apiIdentifier: string;
  description: string;
  maxTokens?: number;
  temperature?: number;
}

export const models: Array<Model> = [
  {
    id: 'gpt-4o-mini',
    label: 'GPT 4o mini',
    apiIdentifier: 'gpt-4o-mini',
    description: 'å¿«é€Ÿè½»é‡çº§ä»»åŠ¡çš„å°å‹æ¨¡å‹',
    maxTokens: 4096,
    temperature: 0.7,
  },
  {
    id: 'gpt-4o',
    label: 'GPT 4o',
    apiIdentifier: 'gpt-4o',
    description: 'å¤æ‚å¤šæ­¥éª¤ä»»åŠ¡çš„å¼ºå¤§æ¨¡å‹',
    maxTokens: 8192,
    temperature: 0.7,
  },
] as const;

export const DEFAULT_MODEL_NAME: string = 'gpt-4o-mini';

export function getModelById(id: string): Model | undefined {
  return models.find(model => model.id === id);
}
```

## æç¤ºè¯ç®¡ç†

@prompt_rules [
  {
    "id": "template_based",
    "rule": "ä½¿ç”¨æ¨¡æ¿åŒ–æç¤ºè¯",
    "severity": "warning"
  },
  {
    "id": "context_aware",
    "rule": "æç¤ºè¯è¦è€ƒè™‘ä¸Šä¸‹æ–‡",
    "severity": "warning"
  },
  {
    "id": "role_definition",
    "rule": "æ˜ç¡®å®šä¹‰ AI è§’è‰²",
    "severity": "warning"
  },
  {
    "id": "safety_guidelines",
    "rule": "åŒ…å«å®‰å…¨ä½¿ç”¨æŒ‡å—",
    "severity": "error"
  }
]

```typescript
// âœ… æç¤ºè¯æ¨¡æ¿ (ai/prompts.ts)
export interface PromptTemplate {
  system: string;
  user?: string;
  variables?: string[];
}

export const CHAT_PROMPTS = {
  default: {
    system: `ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨ã€å‡†ç¡®ã€è¯šå®çš„ AI åŠ©æ‰‹ã€‚è¯·éµå¾ªä»¥ä¸‹å‡†åˆ™ï¼š

1. æä¾›å‡†ç¡®ã€æœ‰ç”¨çš„ä¿¡æ¯
2. æ‰¿è®¤ä¸ç¡®å®šæ€§ï¼Œä¸ç¼–é€ ä¿¡æ¯
3. ä¿æŒå‹å¥½å’Œä¸“ä¸šçš„è¯­è°ƒ
4. å¦‚æœé—®é¢˜æ¶‰åŠæ•æ„Ÿå†…å®¹ï¼Œè¯·ç¤¼è²Œåœ°æ‹’ç»
5. ä¼˜å…ˆè€ƒè™‘ç”¨æˆ·å®‰å…¨å’Œéšç§

å½“å‰æ—¶é—´ï¼š{currentTime}
ç”¨æˆ·è¯­è¨€åå¥½ï¼š{language}`,
    variables: ['currentTime', 'language'],
  },

  coding: {
    system: `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç¼–ç¨‹åŠ©æ‰‹ã€‚è¯·éµå¾ªä»¥ä¸‹å‡†åˆ™ï¼š

1. æä¾›æ¸…æ™°ã€å¯è¿è¡Œçš„ä»£ç ç¤ºä¾‹
2. è§£é‡Šä»£ç çš„å·¥ä½œåŸç†
3. éµå¾ªæœ€ä½³å®è·µå’Œç¼–ç è§„èŒƒ
4. è€ƒè™‘æ€§èƒ½å’Œå®‰å…¨æ€§
5. æä¾›é”™è¯¯å¤„ç†å»ºè®®

æŠ€æœ¯æ ˆï¼šNext.js 15, React 19, TypeScript, Supabase
ç¼–ç é£æ ¼ï¼š{codingStyle}`,
    variables: ['codingStyle'],
  },

  document_analysis: {
    system: `ä½ æ˜¯ä¸€ä¸ªæ–‡æ¡£åˆ†æä¸“å®¶ã€‚è¯·åˆ†ææä¾›çš„æ–‡æ¡£å†…å®¹å¹¶ï¼š

1. æ€»ç»“ä¸»è¦å†…å®¹
2. æå–å…³é”®ä¿¡æ¯
3. å›ç­”ç›¸å…³é—®é¢˜
4. ä¿æŒå®¢è§‚å’Œå‡†ç¡®
5. å¼•ç”¨å…·ä½“çš„æ–‡æ¡£éƒ¨åˆ†

æ–‡æ¡£ç±»å‹ï¼š{documentType}
åˆ†æé‡ç‚¹ï¼š{analysisFocus}`,
    variables: ['documentType', 'analysisFocus'],
  },
} as const;

export function buildPrompt(
  template: PromptTemplate,
  variables: Record<string, string> = {}
): string {
  let prompt = template.system;

  // æ›¿æ¢å˜é‡
  if (template.variables) {
    for (const variable of template.variables) {
      const value = variables[variable] || '';
      prompt = prompt.replace(`{${variable}}`, value);
    }
  }

  return prompt;
}

// âœ… å®‰å…¨è¿‡æ»¤
export function sanitizeUserInput(input: string): string {
  // ç§»é™¤æ½œåœ¨çš„æ³¨å…¥æ”»å‡»
  return input
    .replace(/\{[^}]*\}/g, '') // ç§»é™¤æ¨¡æ¿å˜é‡
    .replace(/<script[^>]*>.*?<\/script>/gi, '') // ç§»é™¤è„šæœ¬æ ‡ç­¾
    .trim();
}
```

## æµå¼å“åº”å¤„ç†

@streaming_rules [
  {
    "id": "use_streaming",
    "rule": "ä¼˜å…ˆä½¿ç”¨æµå¼å“åº”",
    "severity": "warning"
  },
  {
    "id": "error_recovery",
    "rule": "å¤„ç†æµå¼å“åº”ä¸­æ–­",
    "severity": "error"
  },
  {
    "id": "progress_indication",
    "rule": "æ˜¾ç¤ºå“åº”è¿›åº¦",
    "severity": "warning"
  }
]

```typescript
// âœ… æµå¼èŠå¤© API (app/(chat)/api/chat/route.ts)
import { openai } from '@ai-sdk/openai';
import { streamText } from 'ai';
import { NextRequest } from 'next/server';
import { buildPrompt, CHAT_PROMPTS, sanitizeUserInput } from '@/ai/prompts';
import { getModelById } from '@/ai/models';

export async function POST(request: NextRequest) {
  try {
    const { messages, modelId = 'gpt-4o-mini' } = await request.json();

    // éªŒè¯è¾“å…¥
    if (!messages || !Array.isArray(messages)) {
      return new Response('Invalid messages format', { status: 400 });
    }

    // è·å–æ¨¡å‹é…ç½®
    const model = getModelById(modelId);
    if (!model) {
      return new Response('Invalid model', { status: 400 });
    }

    // æ„å»ºç³»ç»Ÿæç¤ºè¯
    const systemPrompt = buildPrompt(CHAT_PROMPTS.default, {
      currentTime: new Date().toISOString(),
      language: 'zh-CN',
    });

    // æ¸…ç†ç”¨æˆ·è¾“å…¥
    const cleanMessages = messages.map(msg => ({
      ...msg,
      content: sanitizeUserInput(msg.content),
    }));

    // æµå¼ç”Ÿæˆå“åº”
    const result = await streamText({
      model: openai(model.apiIdentifier),
      system: systemPrompt,
      messages: cleanMessages,
      maxTokens: model.maxTokens,
      temperature: model.temperature,
      onFinish: async ({ text, usage }) => {
        // ä¿å­˜èŠå¤©è®°å½•
        console.log('Generated text:', text);
        console.log('Token usage:', usage);
      },
    });

    return result.toAIStreamResponse();
  } catch (error) {
    console.error('Chat API error:', error);
    return new Response('Internal server error', { status: 500 });
  }
}
```

## å®¢æˆ·ç«¯ AI é›†æˆ

@client_ai_rules [
  {
    "id": "use_ai_hooks",
    "rule": "ä½¿ç”¨ AI SDK æä¾›çš„ Hooks",
    "severity": "warning"
  },
  {
    "id": "loading_states",
    "rule": "å¤„ç†åŠ è½½çŠ¶æ€",
    "severity": "warning"
  },
  {
    "id": "error_boundaries",
    "rule": "ä½¿ç”¨é”™è¯¯è¾¹ç•Œ",
    "severity": "warning"
  }
]

```typescript
// âœ… èŠå¤©ç»„ä»¶ (components/custom/chat-interface.tsx)
'use client';

import { useChat } from 'ai/react';
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card } from '@/components/ui/card';

interface ChatInterfaceProps {
  chatId: string;
  initialMessages?: any[];
}

export function ChatInterface({ chatId, initialMessages = [] }: ChatInterfaceProps) {
  const [selectedModel, setSelectedModel] = useState('gpt-4o-mini');

  const {
    messages,
    input,
    handleInputChange,
    handleSubmit,
    isLoading,
    error,
    reload,
    stop,
  } = useChat({
    api: '/api/chat',
    initialMessages,
    body: {
      modelId: selectedModel,
      chatId,
    },
    onError: (error) => {
      console.error('Chat error:', error);
    },
    onFinish: (message) => {
      console.log('Message finished:', message);
    },
  });

  return (
    <div className="flex flex-col h-full">
      {/* æ¶ˆæ¯åˆ—è¡¨ */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message) => (
          <Card key={message.id} className="p-4">
            <div className="flex items-start space-x-3">
              <div className="flex-shrink-0">
                {message.role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–'}
              </div>
              <div className="flex-1">
                <div className="text-sm font-medium mb-1">
                  {message.role === 'user' ? 'ç”¨æˆ·' : 'AI åŠ©æ‰‹'}
                </div>
                <div className="text-sm whitespace-pre-wrap">
                  {message.content}
                </div>
              </div>
            </div>
          </Card>
        ))}

        {/* åŠ è½½çŠ¶æ€ */}
        {isLoading && (
          <Card className="p-4">
            <div className="flex items-center space-x-2">
              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
              <span className="text-sm text-gray-600">AI æ­£åœ¨æ€è€ƒ...</span>
              <Button
                variant="outline"
                size="sm"
                onClick={stop}
                className="ml-auto"
              >
                åœæ­¢
              </Button>
            </div>
          </Card>
        )}

        {/* é”™è¯¯çŠ¶æ€ */}
        {error && (
          <Card className="p-4 border-red-200 bg-red-50">
            <div className="flex items-center justify-between">
              <span className="text-sm text-red-600">
                å‘ç”Ÿé”™è¯¯ï¼š{error.message}
              </span>
              <Button
                variant="outline"
                size="sm"
                onClick={reload}
              >
                é‡è¯•
              </Button>
            </div>
          </Card>
        )}
      </div>

      {/* è¾“å…¥åŒºåŸŸ */}
      <div className="border-t p-4">
        <form onSubmit={handleSubmit} className="flex space-x-2">
          <Input
            value={input}
            onChange={handleInputChange}
            placeholder="è¾“å…¥æ¶ˆæ¯..."
            disabled={isLoading}
            className="flex-1"
          />
          <Button
            type="submit"
            disabled={isLoading || !input.trim()}
          >
            å‘é€
          </Button>
        </form>
      </div>
    </div>
  );
}
```

## å·¥å…·è°ƒç”¨å’Œç»“æ„åŒ–è¾“å‡º

@tool_calling_rules [
  {
    "id": "define_tools",
    "rule": "æ˜ç¡®å®šä¹‰å¯ç”¨å·¥å…·",
    "severity": "warning"
  },
  {
    "id": "validate_tool_calls",
    "rule": "éªŒè¯å·¥å…·è°ƒç”¨å‚æ•°",
    "severity": "error"
  },
  {
    "id": "handle_tool_errors",
    "rule": "å¤„ç†å·¥å…·æ‰§è¡Œé”™è¯¯",
    "severity": "error"
  }
]

```typescript
// âœ… å·¥å…·å®šä¹‰ (ai/tools.ts)
import { z } from 'zod';
import { tool } from 'ai';

export const searchDocuments = tool({
  description: 'æœç´¢æ–‡æ¡£å†…å®¹',
  parameters: z.object({
    query: z.string().describe('æœç´¢æŸ¥è¯¢'),
    limit: z.number().optional().describe('ç»“æœæ•°é‡é™åˆ¶'),
  }),
  execute: async ({ query, limit = 10 }) => {
    try {
      // å®ç°æ–‡æ¡£æœç´¢é€»è¾‘
      const results = await searchDocumentsInDatabase(query, limit);
      return {
        success: true,
        results,
        count: results.length,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æœç´¢å¤±è´¥',
      };
    }
  },
});

export const createChat = tool({
  description: 'åˆ›å»ºæ–°çš„èŠå¤©ä¼šè¯',
  parameters: z.object({
    title: z.string().describe('èŠå¤©æ ‡é¢˜'),
    userId: z.string().describe('ç”¨æˆ·ID'),
  }),
  execute: async ({ title, userId }) => {
    try {
      const chat = await createNewChat({ title, userId });
      return {
        success: true,
        chatId: chat.id,
        title: chat.title,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'åˆ›å»ºèŠå¤©å¤±è´¥',
      };
    }
  },
});

// âœ… å·¥å…·é›†åˆ
export const availableTools = {
  searchDocuments,
  createChat,
};
```

## AI ä¸­é—´ä»¶

@middleware_rules [
  {
    "id": "rate_limiting",
    "rule": "å®ç°é€Ÿç‡é™åˆ¶",
    "severity": "warning"
  },
  {
    "id": "content_filtering",
    "rule": "è¿‡æ»¤ä¸å½“å†…å®¹",
    "severity": "error"
  },
  {
    "id": "usage_tracking",
    "rule": "è·Ÿè¸ª API ä½¿ç”¨æƒ…å†µ",
    "severity": "warning"
  }
]

```typescript
// âœ… AI ä¸­é—´ä»¶ (ai/custom-middleware.ts)
import { NextRequest, NextResponse } from 'next/server';

interface AIMiddlewareOptions {
  rateLimit?: {
    requests: number;
    window: number; // æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
  };
  contentFilter?: boolean;
  usageTracking?: boolean;
}

export function createAIMiddleware(options: AIMiddlewareOptions = {}) {
  return async (request: NextRequest) => {
    try {
      // é€Ÿç‡é™åˆ¶
      if (options.rateLimit) {
        const rateLimitResult = await checkRateLimit(request, options.rateLimit);
        if (!rateLimitResult.allowed) {
          return new NextResponse('Rate limit exceeded', { status: 429 });
        }
      }

      // å†…å®¹è¿‡æ»¤
      if (options.contentFilter) {
        const body = await request.json();
        const contentCheckResult = await checkContent(body);
        if (!contentCheckResult.safe) {
          return new NextResponse('Content not allowed', { status: 400 });
        }
      }

      // ä½¿ç”¨æƒ…å†µè·Ÿè¸ª
      if (options.usageTracking) {
        await trackAPIUsage(request);
      }

      return NextResponse.next();
    } catch (error) {
      console.error('AI middleware error:', error);
      return new NextResponse('Internal server error', { status: 500 });
    }
  };
}

async function checkRateLimit(
  request: NextRequest,
  config: { requests: number; window: number }
): Promise<{ allowed: boolean; remaining: number }> {
  // å®ç°é€Ÿç‡é™åˆ¶é€»è¾‘
  const clientId = request.ip || 'anonymous';
  // ... é€Ÿç‡é™åˆ¶å®ç°
  return { allowed: true, remaining: config.requests };
}

async function checkContent(body: any): Promise<{ safe: boolean; reason?: string }> {
  // å®ç°å†…å®¹è¿‡æ»¤é€»è¾‘
  const content = body.messages?.map(m => m.content).join(' ') || '';
  
  // ç®€å•çš„å…³é”®è¯è¿‡æ»¤
  const blockedKeywords = ['spam', 'abuse', 'harmful'];
  const hasBlockedContent = blockedKeywords.some(keyword => 
    content.toLowerCase().includes(keyword)
  );

  return {
    safe: !hasBlockedContent,
    reason: hasBlockedContent ? 'Contains blocked content' : undefined,
  };
}

async function trackAPIUsage(request: NextRequest): Promise<void> {
  // å®ç°ä½¿ç”¨æƒ…å†µè·Ÿè¸ª
  const usage = {
    timestamp: new Date(),
    endpoint: request.url,
    userAgent: request.headers.get('user-agent'),
    ip: request.ip,
  };
  
  // ä¿å­˜åˆ°æ•°æ®åº“æˆ–æ—¥å¿—ç³»ç»Ÿ
  console.log('API usage:', usage);
}
```

## é”™è¯¯å¤„ç†å’Œé‡è¯•

@error_handling [
  {
    "id": "graceful_degradation",
    "rule": "ä¼˜é›…é™çº§å¤„ç†",
    "severity": "warning"
  },
  {
    "id": "retry_logic",
    "rule": "å®ç°é‡è¯•æœºåˆ¶",
    "severity": "warning"
  },
  {
    "id": "fallback_responses",
    "rule": "æä¾›å¤‡ç”¨å“åº”",
    "severity": "warning"
  }
]

```typescript
// âœ… AI é”™è¯¯å¤„ç†å·¥å…·
export class AIError extends Error {
  constructor(
    message: string,
    public code: string,
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'AIError';
  }
}

export async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;

      // å¦‚æœæ˜¯ä¸å¯é‡è¯•çš„é”™è¯¯ï¼Œç›´æ¥æŠ›å‡º
      if (error instanceof AIError && !error.retryable) {
        throw error;
      }

      // æœ€åä¸€æ¬¡é‡è¯•å¤±è´¥
      if (i === maxRetries - 1) {
        break;
      }

      // ç­‰å¾…åé‡è¯•
      await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
    }
  }

  throw lastError!;
}

export function handleAIError(error: unknown): AIError {
  if (error instanceof AIError) {
    return error;
  }

  if (error instanceof Error) {
    // æ ¹æ®é”™è¯¯æ¶ˆæ¯åˆ¤æ–­é”™è¯¯ç±»å‹
    if (error.message.includes('rate limit')) {
      return new AIError('API è°ƒç”¨é¢‘ç‡è¿‡é«˜ï¼Œè¯·ç¨åé‡è¯•', 'RATE_LIMIT', true);
    }
    
    if (error.message.includes('timeout')) {
      return new AIError('è¯·æ±‚è¶…æ—¶ï¼Œè¯·é‡è¯•', 'TIMEOUT', true);
    }

    if (error.message.includes('unauthorized')) {
      return new AIError('API å¯†é’¥æ— æ•ˆ', 'UNAUTHORIZED', false);
    }

    return new AIError(error.message, 'UNKNOWN', true);
  }

  return new AIError('æœªçŸ¥é”™è¯¯', 'UNKNOWN', true);
}
```

## ç¦æ­¢æ¨¡å¼

@forbidden_patterns [
  {
    "pattern": "ç¡¬ç¼–ç  API å¯†é’¥",
    "reason": "å®‰å…¨é£é™©",
    "alternative": "ä½¿ç”¨ç¯å¢ƒå˜é‡"
  },
  {
    "pattern": "å¿½ç•¥æµå¼å“åº”",
    "reason": "ç”¨æˆ·ä½“éªŒå·®",
    "alternative": "ä½¿ç”¨ streamText å’Œç›¸å…³ hooks"
  },
  {
    "pattern": "æœªå¤„ç† AI é”™è¯¯",
    "reason": "ç”¨æˆ·ä½“éªŒå·®",
    "alternative": "å®ç°é€‚å½“çš„é”™è¯¯å¤„ç†"
  },
  {
    "pattern": "ç›´æ¥æš´éœ²æç¤ºè¯",
    "reason": "å®‰å…¨å’Œè´¨é‡é—®é¢˜",
    "alternative": "ä½¿ç”¨æç¤ºè¯æ¨¡æ¿å’Œå˜é‡æ›¿æ¢"
  }
]
